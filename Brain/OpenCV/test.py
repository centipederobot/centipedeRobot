# -*- coding: utf-8 -*-
"""AliGPT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_XbQznn6VPdYJ2EYupobZ_vM5vUjV-t0
"""
import cv2
import torch
import numpy as np
from ultralytics import YOLO
from torchvision.transforms import Compose

# ---------- MiDaS ----------
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
# بارگذاری MiDaS + transforms رسمی
midas = torch.hub.load("intel-isl/MiDaS", "MiDaS_small")
midas.eval()

midas_transforms = torch.hub.load("intel-isl/MiDaS", "transforms")
transform = midas_transforms.small_transform

DEPTH_THRESHOLD = 1.0  # فاصله نزدیک (تنظیم عملی با تست)

def process_frame_obstacle_dynamic(frame):
    h, w, _ = frame.shape
    frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

    # ---------- MiDaS ----------
    input_batch = transform(frame_rgb)
    with torch.no_grad():
        depth = midas(input_batch)
        depth = torch.nn.functional.interpolate(
            depth.unsqueeze(1),
            size=(h, w),
            mode="bicubic",
            align_corners=False
        ).squeeze()
    depth_map = depth.cpu().numpy()

    # ---------- پیدا کردن نزدیک‌ترین مانع ----------
    scan_height = int(h*0.4)  # پایین 40% تصویر
    region = depth_map[h-scan_height:h, :]
    min_val = region.min()
    min_loc = np.unravel_index(np.argmin(region), region.shape)
    cy, cx = min_loc
    cy += h - scan_height

    # عرض مانع
    mask = region <= min_val + 0.05
    xs = np.where(mask.any(axis=0))[0]
    if len(xs) > 0:
        x1, x2 = xs[0], xs[-1]
    else:
        x1, x2 = cx, cx

    # ---------------- اندازه متن پویا ----------------
    box_width = x2 - x1
    font_scale = max(0.4, min(1.0, box_width / 200))
    thickness = int(max(1, font_scale * 2))

    # ---------- رسم خطوط و کادر ----------
    cv2.rectangle(frame, (x1, cy-scan_height//20), (x2, cy), (0,255,100), 2)
    cv2.line(frame, (0, cy), (x1, cy), (0,255,0), 2)
    cv2.line(frame, (x2, cy), (w, cy), (0,165,255), 2)

    cam_x, cam_y = w//2, h-1
    cv2.line(frame, (cam_x, cam_y), (cx, cy), (255,0,0), 2)

    # عمق روی خط آبی
    mid_x, mid_y = (cam_x + cx)//2, (cam_y + cy)//2
    cv2.putText(frame, f"Depth: {min_val:.2f}", (mid_x, mid_y),
                cv2.FONT_HERSHEY_SIMPLEX, font_scale, (255,0,255), thickness)

    # خطوط کناری
    cv2.putText(frame, f"L: {x1}px", (10, cy-10),
                cv2.FONT_HERSHEY_SIMPLEX, font_scale, (0,255,0), thickness)
    cv2.putText(frame, f"R: {w-x2}px", (w-150, cy-10),
                cv2.FONT_HERSHEY_SIMPLEX, font_scale, (0,165,255), thickness)

    # ---------- تصمیم حرکتی ----------
    if min_val < DEPTH_THRESHOLD:
        if (w - x2) > x1:
            decision = "TURN RIGHT"
        else:
            decision = "TURN LEFT"
    else:
        decision = "GO FORWARD"

    cv2.putText(frame, f"Decision: {decision}", (30,40),
                cv2.FONT_HERSHEY_SIMPLEX, font_scale+0.4, (0,255,255), thickness+1)

    return frame

img = cv2.imread('sample.jpg')
print(img.shape)  # برای اطمینان

import matplotlib.pyplot as plt

out = process_frame_obstacle(img)
plt.imshow(out)
plt.axis('off')
plt.show()

