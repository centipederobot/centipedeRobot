# -*- coding: utf-8 -*-
"""AliGPT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_XbQznn6VPdYJ2EYupobZ_vM5vUjV-t0
"""
import cv2, asyncio 
import torch
import numpy as np
from ultralytics import YOLO
from torchvision.transforms import Compose

# ---------- YOLO ----------
yolo = YOLO("yolov8n.pt")

# ---------- MiDaS ----------
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
# Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ MiDaS + transforms Ø±Ø³Ù…ÛŒ
midas = torch.hub.load("intel-isl/MiDaS", "MiDaS_small")
midas.eval()

midas_transforms = torch.hub.load("intel-isl/MiDaS", "transforms")
transform = midas_transforms.small_transform

async def yoloProcess(frame):
    results = yolo(frame, conf=0.3, verbose=False)[0]
    await asyncio.sleep(0)
    return results
    
async def midasProcess(frame):
    input_batch = transform(frame)
    with torch.no_grad():
        depth = midas(input_batch)
        depth = torch.nn.functional.interpolate(
            depth.unsqueeze(1),
            size=frame.shape[:2],
            mode="bicubic",
            align_corners=False
        ).squeeze()
    depth_map = depth.cpu().numpy()
    await asyncio.sleep(0)
    return depth_map

async def process_frame(frame):
        """
        Ù¾Ø±Ø¯Ø§Ø²Ø´ ÛŒÚ© ÙØ±ÛŒÙ…:
        - ØªØ´Ø®ÛŒØµ Ø§Ø´ÛŒØ§Ø¡ Ø¨Ø§ YOLOv8
        - ØªØ®Ù…ÛŒÙ† Ø¹Ù…Ù‚ Ø¨Ø§ MiDaS
        - Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† Ø´Ø¦
        - Ø±Ø³Ù… Ø®Ø·ÙˆØ· ÙØ§ØµÙ„Ù‡â€ŒÙ‡Ø§ Ø¨Ø§ Ø±Ù†Ú¯â€ŒÙ‡Ø§ÛŒ Ù…ØªÙ†ÙˆØ¹
        - ØªØµÙ…ÛŒÙ… Ø­Ø±Ú©Øª
        """
        frame = cv2.resize(frame, (640, 480))
        h, w, _ = frame.shape
        frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

        results, depth_map = await asyncio.gather(
            yoloProcess(frame_rgb),
            midasProcess(frame_rgb)
        )
        # ---------------- Ù†Ø²Ø¯ÛŒÚ©â€ŒØªØ±ÛŒÙ† Ù…Ø§Ù†Ø¹ ----------------
        closest_box = None
        min_depth = float("inf")

        if results.boxes is not None:
            for box in results.boxes:
                x1, y1, x2, y2 = map(int, box.xyxy[0])
                cx, cy_bottom = (x1 + x2) // 2, y2  # Ù¾Ø§ÛŒÛŒÙ† Ø¨Ø§Ú©Ø³
                d = depth_map[cy_bottom, cx]
                if d < min_depth:
                    min_depth = d
                    closest_box = (x1, y1, x2, y2)

        # ---------------- ØªØµÙ…ÛŒÙ… Ø­Ø±Ú©ØªÛŒ ----------------
        decision = "GO FORWARD"

        if closest_box:
            x1, y1, x2, y2 = closest_box
            cx = (x1 + x2) // 2
            cy_bottom = y2  # Ù¾Ø§ÛŒÛŒÙ† Ø¨Ø§Ú©Ø³

            # ğŸ”² Ú©Ø§Ø¯Ø± Ø§ØµÙ„ÛŒ - Ø³Ø¨Ø² Ø±ÙˆØ´Ù†
            cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 100), 3)

            # ğŸ“ Ø®Ø·ÙˆØ· ÙØ§ØµÙ„Ù‡ Ø§Ø² Ú©Ù†Ø§Ø±Ù‡â€ŒÙ‡Ø§ Ø¨Ø§ Ø±Ù†Ú¯â€ŒÙ‡Ø§ÛŒ Ù…ØªÙØ§ÙˆØª
            dist_left = x1
            dist_right = w - x2

            cv2.line(frame, (0, cy_bottom), (x1, cy_bottom), (0, 255, 0), 2)       # Ø®Ø· Ú†Ù¾ - Ø³Ø¨Ø²
            cv2.line(frame, (x2, cy_bottom), (w, cy_bottom), (0, 165, 255), 2)     # Ø®Ø· Ø±Ø§Ø³Øª - Ù†Ø§Ø±Ù†Ø¬ÛŒ

            # ğŸŸ¢ Ø®Ø· Ø§Ø² Ù¾Ø§ÛŒÛŒÙ† ØªØµÙˆÛŒØ± â†’ Ù¾Ø§ÛŒÛŒÙ† Ø´Ø¦ (ÙØ§ØµÙ„Ù‡ Ø±Ø¨Ø§Øª ØªØ§ Ù…Ø§Ù†Ø¹)
            cam_x, cam_y = w // 2, h - 1
            cv2.line(frame, (cam_x, cam_y), (cx, cy_bottom), (255, 0, 0), 2)  # Ø¢Ø¨ÛŒ

            # ğŸ“ Ù†Ù…Ø§ÛŒØ´ Ø¹Ù…Ù‚ Ø±ÙˆÛŒ Ø®Ø·
            mid_x, mid_y = (cam_x + cx) // 2, (cam_y + cy_bottom) // 2
            cv2.putText(frame, f"Depth: {min_depth:.2f}", (mid_x, mid_y),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,0,255), 2)  # Ø¨Ù†ÙØ´

            # ğŸ§® Ù†Ù…Ø§ÛŒØ´ Ø·ÙˆÙ„ Ø®Ø·ÙˆØ· Ú©Ù†Ø§Ø±ÛŒ
            cv2.putText(frame, f"L: {dist_left}px", (10, cy_bottom - 15),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,255,0), 2)
            cv2.putText(frame, f"R: {dist_right}px", (w - 150, cy_bottom - 15),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,165,255), 2)

            # ğŸ¤– ØªØµÙ…ÛŒÙ… Ø­Ø±Ú©ØªÛŒ
            if cx < w * 0.4:
                decision = "TURN RIGHT"
            elif cx > w * 0.6:
                decision = "TURN LEFT"
            else:
                decision = "STOP / SLOW"

        # ğŸŸ¡ ØªØµÙ…ÛŒÙ… Ú©Ù„ ØªØµÙˆÛŒØ±
        cv2.putText(frame, f"Decision: {decision}", (30, 40),
                    cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 255), 3)

        return frame, decision


# async def main():
#     img = cv2.imread("sample.jpg")
#     print(img.shape)
#     import matplotlib.pyplot as plt

#     frame, decision = await process_frame(img)
#     plt.imshow(frame)
#     plt.axis('off')
#     plt.show()

# if __name__ == "__main__":
#     asyncio.run(main())