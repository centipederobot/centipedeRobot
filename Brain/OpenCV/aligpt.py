# -*- coding: utf-8 -*-
"""AliGPT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_XbQznn6VPdYJ2EYupobZ_vM5vUjV-t0
"""
import cv2
import torch
import numpy as np
from ultralytics import YOLO
from torchvision.transforms import Compose

# ---------- YOLO ----------
yolo = YOLO("yolov8n.pt")

# ---------- MiDaS ----------
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
# بارگذاری MiDaS + transforms رسمی
midas = torch.hub.load("intel-isl/MiDaS", "MiDaS_small")
midas.eval()

midas_transforms = torch.hub.load("intel-isl/MiDaS", "transforms")
transform = midas_transforms.small_transform

# ---------- پردازش هر فریم ----------
def process_frame(frame):
    h, w, _ = frame.shape
    frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

    # 1️⃣ YOLO
    results = yolo(frame_rgb, conf=0.3, verbose=False)[0]

    # 2️⃣ MiDaS
    frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

    input_batch = transform(frame_rgb)

    with torch.no_grad():
        prediction = midas(input_batch)
        prediction = torch.nn.functional.interpolate(
            prediction.unsqueeze(1),
            size=frame.shape[:2],
            mode="bicubic",
            align_corners=False,
        ).squeeze()

    depth_map = prediction.cpu().numpy()


    # 3️⃣ نزدیک‌ترین مانع
    closest_box = None
    min_depth = float("inf")

    if results.boxes is not None:
        for box in results.boxes:
            x1, y1, x2, y2 = map(int, box.xyxy[0])
            cx, cy = (x1+x2)//2, (y1+y2)//2
            d = depth_map[cy, cx]

            if d < min_depth:
                min_depth = d
                closest_box = (x1, y1, x2, y2)

    # 4️⃣ تصمیم حرکتی
    decision = "GO FORWARD"

    if closest_box:
        x1, y1, x2, y2 = closest_box
        cx = (x1 + x2) // 2

        cv2.rectangle(frame, (x1,y1), (x2,y2), (0,255,0), 2)
        cv2.putText(frame, f"Depth: {min_depth:.2f}",
                    (x1, y1-10),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,255), 2)

        if cx < w * 0.4:
            decision = "TURN RIGHT"
        elif cx > w * 0.6:
            decision = "TURN LEFT"
        else:
            decision = "STOP / SLOW"

    cv2.putText(frame, f"Decision: {decision}",
                (30,40),
                cv2.FONT_HERSHEY_SIMPLEX, 1, (0,255,255), 3)

    return frame

# ---------- تست با یک تصویر ----------
img = cv2.imread("sample.jpg")
print(img.shape)  # برای اطمینان

import matplotlib.pyplot as plt

out = process_frame(img)
plt.imshow(out)
plt.axis('off')
plt.show()

